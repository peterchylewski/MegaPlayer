'use strict';

var events = require('events'),
	util = require('util'),
	charsetDetector = require('node-icu-charset-detector'),
	Iconv  = require('iconv').Iconv,
	_s = require('underscore.string'),
	spawn = require('child_process').spawn,
	exec = require('child_process').exec;

var SimplePlayer = function() {
	console.log('SimplePlayer!');
	
	var _self = this,
		_volume = 40,
		_mplayer;
			
	this.prev = function() {
		console.log('SimplePlayer.prev');
	};
	
	this.next = function() {
		console.log('SimplePlayer.next');
	};
	
	this.play = function(file) {
		console.log('SimplePlayer.play', file);
		
		if (_mplayer !== undefined) {
			//_mplayer.kill('SIGHUP');
			_self.stop(function() {
				_self.start(file);
			});
		} else {
			_self.start(file);
		}
	};
	
	this.start = function(file) {
		console.log('SimplePlayer.start', file);
		_mplayer = spawn('mplayer', ['-slave', file, '-volume', _volume], function() {
			console.log('*************** mplayer spawned """""""""""""""');
		});
		console.log('PID:', _mplayer.pid);
		
		_mplayer.stdout.once('data', function(buffer) { _decodePlayerMessage(buffer); } );
		//_mplayer.stderr.on('data', function(buffer) { console.log('stderr:', buffer.toString()); });
	};
	
	this.mute = function() {
   		_sendCommand('mute');
    };
	
	this.pause = function() {
		_sendCommand('pause');
	};

	this.stop = function(callback) {
		console.log('SimplePlayer.stop');
		if (_mplayer !== undefined) {
			console.log('sending SIGTERM to player...');
			_mplayer.kill('SIGTERM');
			if (callback !== undefined) { callback(); }
		}
	};
	
	this.volumeUp = function(incr) {
		incr = incr !== undefined ? incr : 10;
		_volume = _volume + incr;
		if (_volume > 100) { _volume = 100; }
		_self.setVolume(_volume);
	};
	
	this.volumeDown = function(decr) {
		decr = decr !== undefined ? decr : 10;
		_volume = _volume - decr;
		if (_volume < 0) { _volume = 0; }
		_self.setVolume(_volume);
	};
	
	this.setVolume = function(volume) {
		console.log('MPlayer.setVolume', volume);
		_volume = volume;
		_sendCommand('volume ' + _volume +  ' 1');
    };
    
    this.getInfo = function(callback) {
    	console.log('MPlayer.getInfo');
    	_sendCommand('get_time_length');
	};
	
	function _sendCommand(cmd) {
		if (_mplayer !== undefined) {
			_mplayer.stdin.write(cmd + '\n');
			_mplayer.stdout.once('data', function(buffer) {
				console.log('***', buffer.toString());
			});
		}
	}
	
	function _fixEncoding(buffer) {
		var charset = charsetDetector.detectCharset(buffer),
			charsetConverter = new Iconv(charset.toString(), 'UTF-8');
		
		//console.log("charset name: " + charset.toString());
		//console.log("language: " + charset.language);
		//console.log("detection confidence: " + charset.confidence);
				
		return charsetConverter.convert(buffer);
	}
	
	function _sanitizeUTF8String(s) {
		
		// experimental https://github.com/felixge/node-unicode-sanitize/blob/master/index.js
		
		var replacement = '\ufffd';
		// https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
		var loneSurrogates = /[\uD800-\uDBFF](?![\uDC00-\uDFFF])|([^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;

		// string sanitizes the given str by replacing invalid UTF-16 code unit
		// sequences with the unicode replacement character. Returns a new string.
		return s.replace(loneSurrogates, '$1' + replacement);
	}
	
	function _decodePlayerMessage(buffer) {
		
		var raw = _s.trim(buffer.toString());
		
		buffer = _fixEncoding(buffer);
		
		var s = _s.trim(buffer.toString());
		s = _sanitizeUTF8String(s);
		
		var name = s.match(/^Name(.*)$/);
		if (name !== null) {
			console.log('>>>>>>>>>>>>>>name', name[1]);
			_self.emit('foo',_s.trim(name[1], ': '));
		}
		
		var audio = s.match(/^AUDIO: (.*)/);
		if (audio !== null) {
			console.log('>>>AUDIO', audio[1].split(', '));
		}
		
		var icy = s.match(/^ICY Info\: StreamTitle=\'([^\']*)\';/);
		
		if (icy !== null) {
			
			console.log('raw:"' +  raw + '"');
			console.log('***:"' + s + '"');
			
			var msg = _s.trim(icy[1], ': ');
			
			console.log('msg:"' + msg + '"');
			
			if (msg !== undefined && msg !== '') {
				_self.emit('foo', msg + ' ');
			}
		}	
	}
	
	
	// ---------------- exit handlers
	
	// do something when app is closing
	process.on('exit', _exitHandler.bind(null, { cleanup: true }));
	
	// catches ctrl+c event
	process.on('SIGINT', _exitHandler.bind(null, { exit: true,  cleanup: true }));
	
	function _exitHandler(options, err) {
	    
	    if (err === true) {
			console.log(err.stack);
		}
	    if (options.exit === true ) {
			if (options.cleanup === true)  {
				console.log('cleaning up...');
				mplayer.kill('SIGHUP');
			}
			console.log('Goodbye!');
			process.exit();
		}
	}
};

events.EventEmitter.call(SimplePlayer);
util.inherits(SimplePlayer, events.EventEmitter);
//emitter.setMaxListeners(5);
process.stdin.setMaxListeners(0);
process.on('uncaughtException', function(e) {
	console.log('process uncaughtException', e);
});

module.exports = new SimplePlayer();

// http://stackoverflow.com/questions/12736723/how-can-i-use-child-process-spawn-to-pause-a-media-player