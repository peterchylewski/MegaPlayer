'use strict';

var events = require('events'),
	util = require('util'),
	charsetDetector = require('node-icu-charset-detector'),
	Iconv  = require('iconv').Iconv,
	_ = require('underscore'),
	_s = require('underscore.string'),
	spawn = require('child_process').spawn;

var SimplePlayer = function() {
	console.log('SimplePlayer!');
	
	var _self = this,
		_volume = 40,
		_info = {},
		_autoInfoIntervalID,
		_mode,
		_mplayer;
			
	this.prev = function() {
		console.log('SimplePlayer.prev');
	};
	
	this.next = function() {
		console.log('SimplePlayer.next');
	};
	
	this.play = function(file) {
		console.log('SimplePlayer.play', file);
		
		_self.start(file);
		return;
		
		if (_mplayer !== undefined) {
			//_mplayer.kill('SIGHUP');
			_self.stop(function() {
				_self.start(file);
			});
		} else {
			_self.start(file);
		}
	};
	
	this.start = function(file) {
		
		file = file.replace("'", "\'");
		console.log('SimplePlayer.start', file);
		
		var options = ['-slave', file, '-volume', _volume, '-cache', '40', '-msglevel', 'statusline=6', '-msglevel', 'global=6'],
			_mode = file.indexOf('http') === 0 ? 'streaming' : 'static'; // this is not a very good distinction...
		
		console.log('_mode', _mode);
		
		_info = {};
		
		if (_mplayer === undefined || _mplayer === null) {
			console.log(options.join(' '));
			_mplayer = spawn('mplayer', options, function() {
				console.log('*************** mplayer spawned """""""""""""""');
				console.log('PID:', _mplayer.pid);
			});
			_startListeningToPlayer();
			_sendCommand('get_property path');
		} else {
			_sendCommand('loadfile "' + file + '"\nvolume ' + _volume +  ' 1');
			_self.getInfo();
		}
		
		
		//_mplayer.stderr.on('data', function(buffer) { console.log('stderr:', buffer.toString()); });
	};
	
	this.mute = function() {
   		_sendCommand('mute');
   		_self.getInfo();
    };
	
	this.pause = function() {
		console.log('SimplePlayer.pause');
		_sendCommand('pause');
		_self.getInfo();
	};

	this.stop = function(callback) {
		console.log('SimplePlayer.stop');
		if (_mplayer !== undefined && _mplayer !== null) {
			console.log('sending SIGTERM to player...');
			_mplayer.kill('SIGTERM');
			_mplayer = null;
			console.log('_mplayer', _mplayer);
			if (callback !== undefined) { callback(); }
		}
	};
	
	this.volumeUp = function(incr) {
		_volume = _volume + (incr !== undefined ? incr : 10);
		if (_volume > 100) { _volume = 100; }
		_self.setVolume(_volume);
	};
	
	this.volumeDown = function(decr) {
		_volume = _volume - (decr !== undefined ? decr : 10);
		if (_volume < 1) { _volume = 1; }
		_self.setVolume(_volume);
	};
	
	this.setVolume = function(volume, feedback) {
		console.log('SimplePlayer.setVolume', volume);
		_volume = volume;
		_sendCommand('volume ' + _volume +  ' 1');
		if (feedback !== false) {
			_sendCommand('get_property volume');
		}
    };
    
    this.setAutoInfoInterval = function(time) {
    	_autoInfoIntervalID = setInterval(function() {
    		_self.getInfo();
    	}, time);
    };
    
    this.getInfo = function() {
    	console.log('SimplePlayer.getInfo');
		var commands = [
			'get_file_name',
			'get_meta_album',
			'get_meta_artist',
			'get_meta_comment',
			'get_meta_genre',
			'get_meta_title',
			'get_meta_track',
			'get_meta_year',
			'get_audio_bitrate',
			'get_audio_codec',
			'get_audio_format',
			'get_audio_samples',
			'get_time_length',
			'get_time_pos',
			'get_percent_pos',
			'get_property percent_pos',
			'get_property volume',
			'get_property balance',
			'get_property filename',
			'get_property pause',
			'get_property paused',
			'get_property mute',
			'get_property path',
			'get_property titles',
			'get_property channels',
			'get_property metadata',
			'get_property loop',
			'get_property speed',
			'get_property titles',
			'get_property demuxer'
		];
		_sendCommand(commands.join('\n'));
	};
	
	this.getInfo = function() {
		return _info;
	};
	
	function _startListeningToPlayer() {
		_mplayer.stdout.on('data', function(buffer) {
			_decodePlayerMessage(buffer);
		} );
	}
	
	function _sendCommand(cmd) {
		//console.log('MPlayer._sendCommand', cmd);
		if (_mplayer !== undefined) {
			_mplayer.stdin.write(cmd + '\n');
		}
	}
	
	function _fixEncoding(buffer) {
		var charset = charsetDetector.detectCharset(buffer),
			charsetConverter = new Iconv(charset.toString(), 'UTF-8');
		
		//console.log("charset name: " + charset.toString());
		//console.log("language: " + charset.language);
		//console.log("detection confidence: " + charset.confidence);
				
		return charsetConverter.convert(buffer);
	}
	
	function _sanitizeUTF8String(s) {
		
		// experimental https://github.com/felixge/node-unicode-sanitize/blob/master/index.js
		
		var replacement = '\ufffd';
		// https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
		var loneSurrogates = /[\uD800-\uDBFF](?![\uDC00-\uDFFF])|([^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;

		// string sanitizes the given str by replacing invalid UTF-16 code unit
		// sequences with the unicode replacement character. Returns a new string.
		return s.replace(loneSurrogates, '$1' + replacement);
	}
	
	function _decodePlayerMessage(buffer) {
		
		var raw = _s.trim(buffer.toString());
		
		buffer = _fixEncoding(buffer);
		
		var s = _s.trim(buffer.toString());
		s = _sanitizeUTF8String(s);
		
		var name = s.match(/^Name(.*)$/);
		if (name !== null) {
			console.log('>>>>>>>>>>>>>>name', name[1]);
			_self.emit('foo', _s.trim(name[1], ': '));
		}		
		
		var lines = _s.trim(raw).split('\n'),
			info = {}, ans, audio, icy, eof, exitCode,
			key, value;
		
		console.log(lines.length, ' lines detected');
		
		if (lines.length === 1) {
			detect(s);
		} else {
			_.each(lines, function(line) {
				detect(line);
			});
		}
		
		function detect(s) {
		
			console.log(s);
		
			// --------------- detect ans message
			
			ans = s.match(/^ANS_([^=]*)=(.*)/);
			if (ans !== null) {
				//console.log('ANS MESSAGE DETECTED', ans);
				key = _s.camelize(ans[1].toLowerCase().replace(/_/g, '-'));
				value = _s.trim(ans[2], '\'');
				if (value !== undefined && value !== null && value !== '') {
					info[key] = value;
				}
				ans = null;
			}
			
			// --------------- detect icy message
			
			icy = s.match(/^ICY Info\: StreamTitle=\'([^\']*)\';/);
		
			if (icy !== undefined &&  icy !== null) {
			
				console.log('raw:"' +  raw + '"');
				console.log('***:"' + s + '"');
			
				var msg = _s.trim(icy[1], ': ');
			
				console.log('msg:"' + msg + '"');
			
				if (msg !== undefined && msg !== '') {
					_self.emit('station_message', msg + ' ');
				}
				
				icy = null;
			}			
			
			
			// --------------- detect eof message
			
			eof = s.match(/^EOF(.*)$/);
			if (eof !== null) {
				exitCode = eof[1];
				console.log('>>>>>>>EOF', exitCode);
				console.log('_mode', _mode);
				if (_mode === 'static' && exitCode === 1) {
					console.log('end of static file reached');
					_self.emit('end_of_file_reached');
					//_self.stop();
					_mplayer.kill();
				}
				eof = null;
			}
			
			// --------------- detect audio message
			
			audio = s.match(/^AUDIO: (.*)/);
			if (audio !== undefined && audio !== null) {
				console.log('>>>AUDIO', audio[1].split(', '));
				audio = null;
				console.log('audio', audio);
			}
		
		}
				
		//console.log('info', info);
		
		_.each(info, function(value, key) {
			if (value !== undefined && value !== _info[key]) {
				//console.log('value changed:', key, value);
				_self.emit('valueChanged', key, value);
				_info[key] = value;
			}
		});	
		
		//_info = info;
			
	}
	
	// ---------------- uncaught exception handler
	
	process.on('uncaughtException', function(e) {
		console.log('process uncaughtException', e);
		//_self.stop();
	});


	// ---------------- exit handlers
	
	// do something when app is closing
	process.on('exit', _exitHandler.bind(null, { cleanup: true }));
	
	// catches ctrl+c event
	process.on('SIGINT', _exitHandler.bind(null, { exit: true,  cleanup: true }));
	
	function _exitHandler(options, err) {
	    console.log('SimplePlayer._exitHandler', err);
	    return;
	    if (err === true) {
			console.log(err.stack);
		}
	    if (options.exit === true ) {
			if (options.cleanup === true)  {
				console.log('cleaning up...');
				mplayer.kill('SIGHUP');
			}
			console.log('Goodbye!');
			process.exit();
		}
	}
};

events.EventEmitter.call(SimplePlayer);
util.inherits(SimplePlayer, events.EventEmitter);
//emitter.setMaxListeners(5);
process.stdin.setMaxListeners(0);


module.exports = new SimplePlayer();

// http://stackoverflow.com/questions/12736723/how-can-i-use-child-process-spawn-to-pause-a-media-player