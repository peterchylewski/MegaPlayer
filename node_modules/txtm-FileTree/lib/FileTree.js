'use strict';

var fs = require('fs'),
	path = require('path'),
	util = require('util'),
	$ = require('jquery'),
	_ = require('underscore'),
	moment = require('moment');
	
var FileTree = function(dir, options) {
	
	console.log('FileTree!', dir, options);
	
	// ------- V 0.3
	
	var _self = this,
		_dir = dir,
		_defaults = {
			addDates: false,
			includeFilesWithExtensions: ['flac'],
			excludeFilesWithExtensions: ['m3u']
		},
		_options = _.extend(_defaults, options),
		_tree,
		_$target,
		_$fileTree;
	
	function _init() {
		console.log('FileTree._init', _dir);
		console.log('_options', _options);
		_tree = _self.walk(_dir);
	}
			
	function _addEvents() {
		console.log('FileTree._addEvents');
		
		var $folders = $('.folder'),
			$files = $('.file');
			
		$folders.each(function() {
			var $folder = $(this);
			$folder.find('.item:first .title').click(function() {
				console.log('a folder item was clicked');
				$folder.data('isExpanded', $folder.data('isExpanded') !== undefined ? !$folder.data('isExpanded') : true);
				var $glyphicon = $folder.find('.glyphicon:first');
				if ($folder.data('isExpanded') === false) {
					$glyphicon
						.removeClass('glyphicon-folder-close')
						.addClass('glyphicon-folder-open');
					$folder.parent().find('.FileTree:first').show();
				} else {
					$glyphicon
						.removeClass('glyphicon-folder-open')
						.addClass('glyphicon-folder-close');
					$folder.parent().find('.FileTree:first').hide();
				}
			});
		});
		
		$files.each(function() {
			var $file = $(this);
			$file.find('.item:first .title').click(function() {
				console.log('a file item was clicked');
				if (_options.click !== undefined) { _options.click($file); }
			});
		});
		
		fs.watch(dir, function() {
			console.log('something changed');
			_refresh();
		});
	}
	
	function _refresh() {
		_self.render(_$target, true);
	}
	
	this.walk = function(filename) {
		//console.log('filename', filename);
		var stats = fs.lstatSync(filename),
			info = {
				path: path.resolve(filename),
				name: path.basename(filename),
			};

		if (_options.addDates === true) {
			info.birthtime = stats.birthtime;
			info.atime = stats.atime;
			info.ctime = stats.ctime;
			info.mtime = stats.mtime;
		}

		if (info.name.indexOf('.') === 0 || info.name.indexOf('_stuff') === 0) {
			//console.log('skipping "' + info.path + '"...');
			return null;
		}

		if (stats.isDirectory() === true) {
	 		info.type = 'folder';
			try {
				var pathToMeta = path.resolve(filename, '_meta.json');
				// console.log('pathToMeta', pathToMeta);
				if (fs.existsSync(pathToMeta) === true) {
					// console.log('meta file found');
					// console.log('pathToMeta', pathToMeta);
					info.meta = require(pathToMeta);
				}
			} catch(e) {
				console.log('ERROR: ' + e.message);
			}
			var children = fs.readdirSync(filename).sort(naturalSort),
				result;
			info.children = [];
			children.forEach(function(child) {
				result = _self.walk(path.resolve(filename, child));
				if (result !== null) { info.children.push(result); } 
			});
			/*
			info.children = children.map(function(child) {
				// console.log('child', child);
				return _self.walk(path.resolve(filename, child));
			});
			*/
		} else {
			// Assuming it's a file. In real life it could be a symlink or
			// something else!
			info.type = 'file';
			info.extension = path.extname(filename).replace(/^\./, '');
			
			if (_options.includeFilesWithExtensions.length > 0) {
			
				//console.log(_.indexOf(_options.includeFilesWithExtensions, info.extension));
				if (_.indexOf(_options.includeFilesWithExtensions, info.extension) === -1) {
					return null;
				}
			}
			
			/*
			// console.log(info.name);
			if (_options.includeFilesWithExtensions.length > 0) {
			
				//console.log(_.indexOf(_options.includeFilesWithExtensions, info.extension));
				if (_.indexOf(_options.includeFilesWithExtensions, info.extension) === -1) {
					return null;
				}
			}
			*/
		}
		return info;
	};
	
	this.getData = function() {
		return _tree;
	};
	
	this.render = function($target, forceReload) {
		
		_$target = $target;
		
		$target.empty();
		
		if (forceReload === true) { _tree = _self.walk(_dir); }
		
		var pathToTemplate = __dirname + '/../templates/FileTree.tmpl.html',
			templateHTML = fs.readFileSync(pathToTemplate, 'utf8'),
			template = _.template(templateHTML);
		
		var partial = function(depth, obj) {
			depth = depth + 1;
			return template({tree: obj, depth: depth, partial: partial, moment: moment});
		};
		
		_$fileTree = $(partial(- 1, _tree));
		console.log(_$fileTree);
		
		$target.html(_$fileTree);
		_addEvents();
	}
	
	_init();
};

module.exports = function(dir, options) {
	return new FileTree(dir, options);
};

// https://github.com/Bill4Time/javascript-natural-sort/blob/master/naturalSort.js
function naturalSort(a, b) {
	var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
		sre = /(^[ ]*|[ ]*$)/g,
		dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
		hre = /^0x[0-9a-f]+$/i,
		ore = /^0/,
		i = function(s) { return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s; },
		// convert all to strings strip whitespace
		x = i(a).replace(sre, '') || '',
		y = i(b).replace(sre, '') || '',
		// chunk/tokenize
		xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
		yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
		// numeric, hex or date detection
		xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),
		yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,
		oFxNcL, oFyNcL;
	// first try and sort Hex codes or Dates
	if (yD) {
		if ( xD < yD ) { return -1; }
		else if ( xD > yD ) { return 1; }
	}
	// natural sorting through split numeric strings and default strings
	for (var cLoc=0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
		// find floats not starting with '0', string or 0 if not defined (Clint Priest)
		oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
		oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
		// handle numeric vs string comparison - number < string - (Kyle Adams)
		if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
		// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
		else if (typeof oFxNcL !== typeof oFyNcL) {
			oFxNcL += '';
			oFyNcL += '';
		}
		if (oFxNcL < oFyNcL) { return -1; }
		if (oFxNcL > oFyNcL) { return 1; }
	}
	return 0;
};