'use strict';

var events = require('events'),
	readline = require('readline'),
	util = require('util'),
	charsetDetector = require('node-icu-charset-detector'),
	Iconv  = require('iconv').Iconv,
	_ = require('underscore'),
	_s = require('underscore.string'),
	spawn = require('child_process').spawn;

var SimplePlayer = function() {
	console.log('SimplePlayer!');
	
	var _self = this,
		_volume = 5,
		_info = {},
		_autoInfoIntervalID,
		_mode,
		_mplayer;
	
	// --- test
		
   	this.getVolume = function(callback) {
		if (_mplayer !== null) {
			this.rl.question('get_property volume\n', function(answer) {
				callback(answer.split('=')[1]);
        	});
        }
	};
	
	this.getProp = function(key, callback) {
		if (_mplayer !== null) {
			this.rl.question('get_property ' + key + '\n', function(answer) {
				callback(answer.split('=')[1]);
        	});
        }
	};
    
    // --- test (end)
    		
	this.prev = function() {
		console.log('SimplePlayer.prev');
	};
	
	this.next = function() {
		console.log('SimplePlayer.next');
	};
	
	this.play = function(file, newPlayer) {
		console.log('SimplePlayer.play', file, newPlayer);
		_self.start(file, newPlayer);
	};
	
	this.start = function(file, newPlayer) {
		
		file = file.replace("'", "\'");
		
		console.log('SimplePlayer.start', file, newPlayer);
		
		var options = ['-slave', '-idle', '-vo',  'null', '-volume', _volume, '-cache', '80', '-msglevel', 'statusline=6', '-msglevel', 'global=6'],
			_mode = file.indexOf('http') === 0 ? 'streaming' : 'static'; // this is not a very good distinction...
		
		console.log('options', options.join(' '));
		console.log('_mode', _mode);
		
		if (_mplayer !== undefined && _mplayer !== null && _mplayer.stdin !== undefined) {
			//console.log('_mplayer', _mplayer);
			console.log('_mplayer.stdin.readable', _mplayer.stdin.readable);
			console.log('_mplayer.stdin.writable', _mplayer.stdin.writable);
			if (_mplayer.stdin.readable === false ||Â _mplayer.stdin.writable === false) {
				_mplayer.kill();
				_mplayer = undefined;
			}
		}
		
		if (newPlayer === true) {
			_mplayer.kill();
			_mplayer = undefined;
		}
		
		_info = {};
		
		if (_mplayer === undefined || _mplayer === null) {
			console.log(options.join(' '));
			_mplayer = spawn('mplayer', options);
			console.log('*************** mplayer spawned ***************');
			console.log('PID:', _mplayer.pid);
			_self.rl = readline.createInterface({
				input: _mplayer.stdout,
				output: _mplayer.stdin
			});
			
			_mplayer.stdout.on('data', function(buffer) {
				_decodePlayerMessage(buffer);
			} );
		}
		
		if (_mplayer !== undefined && _mplayer !== null) {
			_mplayer.stdin.resume();
			
		}
		
		console.log('\n--------------------------- loading file', file);
		
		_sendCommand('loadfile "' + file + '"\nvolume ' + _volume +  ' 1\n');
		
		/*
		_self.getProp('path', function(data) {
			console.log('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>path', data);
		});
		*/
		
		// bad hack, but it seems to work...
		setTimeout(function() {
			_self.updateStatus();
		}, 1000);
		
			
		
		//_self.setAutoInfoInterval(1000);
		//_mplayer.stderr.on('data', function(buffer) { console.log('stderr:', buffer.toString()); });
	};
	
	this.mute = function() {
		console.log('SimplePlayer.mute');
   		_sendCommand('mute');
   		_self.updateStatus();
    };
	
	this.pause = function() {
		console.log('SimplePlayer.pause');
		_sendCommand('pause');
		_sendCommand('get_property pause', function(data) {
			console.log('data', data);
		});
	};

	this.stop = function(callback) {
		console.log('SimplePlayer.stop');
		if (_mplayer !== undefined && _mplayer !== null) {
			console.log('sending SIGTERM to player...');
			_mplayer.kill('SIGTERM');
			_mplayer = null;
			console.log('_mplayer', _mplayer);
			if (callback !== undefined) { callback(); }
		}
	};
	
	this.volumeUp = function(incr) {
		_volume = _volume + (incr !== undefined ? incr : 10);
		if (_volume > 100) { _volume = 100; }
		_self.setVolume(_volume);
	};
	
	this.volumeDown = function(decr) {
		_volume = _volume - (decr !== undefined ? decr : 10);
		if (_volume < 1) { _volume = 1; }
		_self.setVolume(_volume);
	};
	
	this.setVolume = function(volume, feedback) {
		console.log('SimplePlayer.setVolume', volume);
		_volume = volume;
		_sendCommand('volume ' + _volume +  ' 1');
		
		if (feedback !== false) {
			_sendCommand('get_property volume');
		}
		
		/*
		//if (feedback !== false) {
		_self.getVolume(function(data) {
			console.log('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>volume', data);
		});
		
		_self.getProp('volume', function(data) {
			console.log('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>volume', data);
		});
		
		_self.getProp('path', function(data) {
			console.log('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>path', data);
		});
		
		_self.getProp('filename', function(data) {
			console.log('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>filename', data);
		});
		*/
		
		//}
		//if (feedback !== false) {
		//	_sendCommand('get_property volume');
		//}
		
    };
    
    this.setTimePos = function(time, callback) {
    	_sendCommand('set_property time_pos ' + time);
    	if (callback !== undefined) { callback(); }
    };
    
    this.setAutoInfoInterval = function(time) {
    	clearInterval(_autoInfoIntervalID);
    	_autoInfoIntervalID = setInterval(function() {
    		_sendCommand('get_time_pos');
    	}, time);
    };
    
    this.updateStatus = function(callback) {
    	console.log('SimplePlayer.updateStatus');
		var commands = [
			'get_file_name',
			'get_meta_album',
			'get_meta_artist',
			'get_meta_comment',
			'get_meta_genre',
			'get_meta_title',
			'get_meta_track',
			'get_meta_year',
			'get_audio_bitrate',
			'get_audio_codec',
			'get_audio_format',
			'get_audio_samples',
			'get_time_length',
			'get_time_pos',
			'get_percent_pos',
			'get_property percent_pos',
			'get_property volume',
			'get_property balance',
			'get_property filename',
			'get_property pause',
			'get_property paused',
			'get_property mute',
			'get_property path',
			//'get_property titles',
			'get_property channels',
			'get_property metadata',
			'get_property loop',
			'get_property speed',
			'get_property demuxer'
		];
		_sendCommand(commands.join('\n'), callback);
	};
	
	this.getInfo = function() {
		return _info;
	};
	
	function _sendCommand(cmd, callback) {
		//console.log('MPlayer._sendCommand', cmd);

		
		if (_mplayer !== undefined && _mplayer !== null) {
			_mplayer.stdin.write(cmd + '\n');
		} else {
			console.log('_mplayer not found');
		}
		
		if (callback !== undefined) {
			_mplayer.stdout.once('data', function(buffer) {
				console.log('buffer', buffer);
				_decodePlayerMessage(buffer);
				//callback(buffer.toString(buffer));
			});
		}
	}
	
	function _fixEncoding(buffer) {
		var charset = charsetDetector.detectCharset(buffer),
			charsetConverter = new Iconv(charset.toString() || 'UTF-8', 'UTF-8');
		
		//console.log("charset name: " + charset.toString());
		//console.log("language: " + charset.language);
		//console.log("detection confidence: " + charset.confidence);
				
		return charsetConverter.convert(buffer);
	}
	
	function _sanitizeUTF8String(s) {
		
		// experimental https://github.com/felixge/node-unicode-sanitize/blob/master/index.js
		
		var replacement = '\ufffd';
		// https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
		var loneSurrogates = /[\uD800-\uDBFF](?![\uDC00-\uDFFF])|([^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;

		// string sanitizes the given str by replacing invalid UTF-16 code unit
		// sequences with the unicode replacement character. Returns a new string.
		return s.replace(loneSurrogates, '$1' + replacement);
	}
	
	function _decodePlayerMessage(buffer) {
		//console.log('_decodePlayerMessage', buffer);
		
		var raw = _s.trim(buffer.toString());
		
		buffer = _fixEncoding(buffer);
		
		var s = _s.trim(buffer.toString());
		s = _sanitizeUTF8String(s);
		
		var name = s.match(/^Name(.*)$/);
		if (name !== null) {
			console.log('>>>>>>>>>>>>>>name', name[1]);
			_self.emit('foo', _s.trim(name[1], ': '));
		}		
		
		var lines = _s.trim(raw).split('\n'),
			info = {}, ans, audio, icy, eof, exitCode,
			key, value;
		
		//console.log(lines.length + ' line(s) detected');
		
		if (lines.length === 1) {
			decode(s);
		} else {
			_.each(lines, function(line) {
				decode(line);
			});
		}
		
		function decode(s) {
		
			//console.log('decode', s);
				
			// --------------- detect ans message
			
			ans = s.match(/^ANS_([^=]*)=(.*)/);
			if (ans !== null) {
				//console.log('ANS MESSAGE DETECTED', ans);
				key = _s.camelize(ans[1].toLowerCase().replace(/_/g, '-'));
				
				value = _s.trim(ans[2], '\'');
				if (value !== undefined && value !== null && value !== '') {
					info[key] = value;
					//console.log('ANS', key, value);
				}
				ans = null;
			}
			
			// --------------- detect icy message
			
			icy = s.match(/^ICY Info\: StreamTitle=\'([^\']*)\';/);
		
			if (icy !== undefined &&  icy !== null) {
				console.log('raw:"' +  raw + '"');
				console.log('***:"' + s + '"');
			
				var msg = _s.trim(icy[1], ': ');
				console.log('msg:"' + msg + '"');
			
				if (msg !== undefined && msg !== '') {
					_self.emit('station_message', msg + ' ');
				}
				
				icy = null;
			}			
			
			// --------------- detect audio message
			
			audio = s.match(/^AUDIO: (.*)/);
			if (audio !== undefined && audio !== null) {
				
				console.log('audio', audio);
								
				var a = audio[1].split(', '),
					sampleRateInfo = a[0].match(/([0-9]*) (.*)/),
					channelInfo = a[1].match(/([0-9]*) (.*)/),
					bitsPerSampleInfo = a[2].match(/s([0-9]*)/),
					bitRateInfo = a[3].match(/([0-9\.]*)\W([a-z]*)/);
				
				console.log('a', a);		
				
				info['AUDIO'] = {
					raw: audio,
					sampleRate: 	parseInt(sampleRateInfo[1]),
					sampleRateUnit: sampleRateInfo[2],
					channels: 		parseInt(channelInfo[1]),
					bitsPerSample: 	parseInt(bitsPerSampleInfo[1]),
					bitRate: 		parseFloat(bitRateInfo[1]),
					bitRateUnit: 	bitRateInfo[2]
				};
				console.log(JSON.stringify(info['AUDIO'], null, 2));
				audio = null;
			}
			
			// --------------- detect eof message
			
			eof = s.match(/^EOF code: (.*)$/);
			if (eof !== null) {
				exitCode = eof[1];
				console.log('>>>>>>>EOF', '"' + exitCode + '"', typeof exitCode);
				console.log('_mode', _mode);
				//if (_mode === 'static' && exitCode === 1) {
				if (exitCode === 1 || exitCode === '1') {
					console.log('end of file reached');
					_self.emit('end_of_file_reached');
					//_self.stop();
					//_mplayer.kill();
				}
				eof = null;
			}
		}
				
		//console.log('info', info);
		
		_.each(info, function(value, key) {
			if (value !== undefined && value !== _info[key]) {
				//console.log('value changed:', key, value);
				_self.emit('valueChanged', key, value);
				_info[key] = value;
			}
		});	
		
		_info = info;
			
	}
	
	// ---------------- uncaught exception handler
	
	process.on('uncaughtException', function(e) {
		console.log('process uncaughtException', e);
		
		var debug = ''; 
    	for (var prop in e) {  
			debug += 'property: ' + prop + ' value: [' +  e[prop] +  ']\n'; 
    	} 
    	debug += 'toString(): ' + ' value: [' + e.toString() + ']'; 
    	console.log(debug);
    
	});


	// ---------------- exit handlers
	
	// do something when app is closing
	process.on('exit', _exitHandler.bind(null, { cleanup: true }));
	
	// catches ctrl+c event
	process.on('SIGINT', _exitHandler.bind(null, { exit: true,  cleanup: true }));
	
	function _exitHandler(options, err) {
	    console.log('SimplePlayer._exitHandler', err);
	    return;
	    if (err === true) {
			console.log(err.stack);
		}
	    if (options.exit === true ) {
			if (options.cleanup === true)  {
				console.log('cleaning up...');
				mplayer.kill('SIGHUP');
			}
			console.log('Goodbye!');
			process.exit();
		}
	}
};

events.EventEmitter.call(SimplePlayer);
util.inherits(SimplePlayer, events.EventEmitter);
//emitter.setMaxListeners(5);
process.stdin.setMaxListeners(0);


module.exports = new SimplePlayer();

// http://stackoverflow.com/questions/12736723/how-can-i-use-child-process-spawn-to-pause-a-media-player